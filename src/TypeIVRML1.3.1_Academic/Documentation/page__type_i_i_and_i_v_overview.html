<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Reflexxes Motion Libraries: The Position-based Type IV Online Trajectory Generation Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="./index.html"><img alt="Logo" src="ReflexxesLogoHeader.png" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Reflexxes Motion Libraries&#160;<span id="projectnumber">Manual and Documentation (Type IV, Version 1.3.1, Research and Education)</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>The Position-based Type IV Online Trajectory Generation Algorithm </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>This page contains four sections<br/>
<br/>
</p>
<ul>
<li><a class="el" href="page__type_i_i_and_i_v_overview.html#sec_BriefIntroduction">A Brief Introduction</a><br/>
<br/>
</li>
<li><a class="el" href="page__type_i_i_and_i_v_overview.html#sec_Step1">Step 1: Calculate the Synchronization Time</a><br/>
<br/>
</li>
<li><a class="el" href="page__type_i_i_and_i_v_overview.html#sec_Step2">Step 2: Synchronization of All Selected DOFs</a><br/>
<br/>
</li>
<li><a class="el" href="page__type_i_i_and_i_v_overview.html#sec_Step3">Step 3: Calculate Output Values</a><br/>
<br/>
</li>
</ul>
<hr/>
<h2><a class="anchor" id="sec_BriefIntroduction"></a>
A Brief Introduction</h2>
<div align="center">
<img src="RMLBasicPositionTypeIVColor.png" alt="RMLBasicPositionTypeIVColor.png"/>
<p><strong>Input and output values of the <em>Reflexxes</em> <em>Type</em> <em>IV</em> <em>Motion</em> <em>Library</em> in a generic manner.</strong></p></div>
<p> The interface (<a class="el" href="class_reflexxes_a_p_i.html" title="This class constitutes the API of the Reflexxes Motion Libraries">ReflexxesAPI</a>) of all <em>Reflexxes</em> <em>Motion</em> <em>Libraries</em> is very simple and can easily be integrated into existing systems. Based on the <em>current</em> <em>state</em> <em>of</em> <em>motion</em> and the <em>kinematic</em> <em>motion</em> <em>constraints</em>, a <em>new</em> <em>state</em> <em>of</em> <em>motion</em> is calculated with lies exactly on the time-optimal trajectory to reach the desired <em>target</em> <em>state</em> <em>of</em> <em>motion</em>. All input values can change arbitrarily based on sensor signals and even discontinuously, and a steady jerk-limited motion trajectory is always <em>guaranteed</em> at the output The above figure shows the input and output values of the RML algorithm in a generic manner. It is the task of the algorithm to time-optimally transfer an arbitrary current state of motion<br/>
 <br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf M}_{i}\,=\,\left(\vec{P}_{i},\, \vec{V}_{i},\, \vec{A}_{i} \right) \]" src="form_0.png"/>
</p>
<p> <br/>
 into the desired target state of motion<br/>
 <br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf M}_{i}^{\,trgt}\,=\,\left(\vec{P}_{i}^{\,trgt},\, \vec{V}_{i}^{\,trgt},\, \vec{0} \right) \]" src="form_1.png"/>
</p>
<p> <br/>
 under consideration of the kinematic motion constraints<br/>
 <br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\bf B}_{i}\,=\,\left( \vec{V}_{i}^{\,max},\, \vec{A}_{i}^{\,max},\, \vec{J}_{i}^{\,max} \right) \]" src="form_2.png"/>
</p>
<p><br/>
 <br/>
 The algorithm works memoryless and calculates only the next state of motion <img class="formulaInl" alt="$ {\bf M}_{i+1} $" src="form_3.png"/>, which is used as input value for lower-level motion controllers. The resulting trajectories are time-optimal and synchronized, such that all selected DOFs coinstantaneously reach their target state of motion. The selection vector <img class="formulaInl" alt="$ \vec{S}_i $" src="form_4.png"/> contains boolean values to mask single DOFs, for which no output values are calculated. All types and variant of the algorithm consist of three steps, which are introduced in the following.<br/>
</p>
<div align="center">
<img src="Step1ProfilesLines.png" alt="Step1ProfilesLines.png"/>
<p><strong>A subset of the acceleration profile set of Type IV. The dotted horizontal line indicates the maximum acceleration values. These profiles are required to calculate the minimum execution time as well as all limits of existing inoperative time intervals for each single selected DOF.</strong></p></div>
<p> <br/>
 <br/>
</p>
<p>For a better understanding of the basic algorithm for Type IV Online Trajectory generation (OTG), this section presents a brief overview. For a detailed description, please refer to<br/>
 <br/>
 <b>T. Kroeger.</b><br/>
 <b>On-line Trajectory Generation in Robotic Systems.</b><br/>
 <b>Springer Tracts in Advanced Robotics, Vol. 58, Springer, January 2010.</b><br/>
 <b><a href="http://www.springer.com/978-3-642-05174-6" target="_blank" title="You may order your personal copy at www.springer.com.">http://www.springer.com/978-3-642-05174-6</a></b><br/>
<br/>
</p>
<p><br/>
 <br/>
</p>
<hr/>
<h2><a class="anchor" id="sec_Step1"></a>
Step 1: Calculate the Synchronization Time</h2>
<p>Although only one single scalar value is calculate in this step, it the the most complex one. First, the minimum execution times <img class="formulaInl" alt="$ _kt_{i}^{\,min} $" src="form_5.png"/> are calculated for each selected DOF <img class="formulaInl" alt="$ k \ \in\ \{1,\dots,K\}$" src="form_6.png"/>. The value of the minimum synchronization time <img class="formulaInl" alt="$ t_i^{\,sync} $" src="form_7.png"/> must be equal or greater than the minimum value of all minimum execution times. To transfer the motion state of one degree of freedom to another, a finite set of motion profiles <img class="formulaInl" alt="$ {\cal P}_{Step1} $" src="form_8.png"/> is considered, and a decision tree selects a motion profile <img class="formulaInl" alt="$ _k\Psi_i^{\,Step1}\ \in\ {\cal P}_{Step1} $" src="form_9.png"/> for each selected DOF <img class="formulaInl" alt="$ k \ \in\ \{1,\dots,K\} $" src="form_10.png"/>. To calculate <img class="formulaInl" alt="$ _kt_{i}^{\,min} $" src="form_5.png"/>, a system of nonlinear equation is set-up, and the solution contains the desired value. The above figure exemplarily shows a subset of the set of acceleration profiles for the Type IV OTG algorithm.<br/>
 <br/>
 Depending on the type of the algorithm (I-IX), it may happen that up to <img class="formulaInl" alt="$ Z\,=\,3 $" src="form_11.png"/> time intervals are existent, within which the target state of motion cannot be reached. For the Type IV algorithm only <img class="formulaInl" alt="$ Z\,=\,1 $" src="form_12.png"/> inoperative interval may be existent. The decision trees 1B (consisting of 1B1, 1B2, and 1B3) and 1C are used to calculate all limits of these intervals <img class="formulaInl" alt="$ _k{\cal Z}_{i} $" src="form_13.png"/>, whose elements are denoted by<br/>
 <br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ _k^z\zeta_{i}\,=\,\left[^z_kt_{i}^{\,begin},\,^z_kt_{i}^{\,end}\right],\ \mbox{with}\ z\ \in\ \left\{1,\,\dots,\,Z\right\} \]" src="form_14.png"/>
</p>
<p><br/>
 <br/>
 Finally, the minimum time not being within any inoperative time interval<br/>
 <br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ _k^z\zeta_{i}\ \forall\ (z,\,k)\ \in \ \left\{1,\,\dots,\,Z\right\}\times\left\{1,\,\dots,\,K\right\} \]" src="form_15.png"/>
</p>
<p> <br/>
 <br/>
 is selected as the value for the synchronization time <img class="formulaInl" alt="$ t_i^{\,sync} $" src="form_7.png"/>.</p>
<p><br/>
 <br/>
</p>
<hr/>
<h2><a class="anchor" id="sec_Step2"></a>
Step 2: Synchronization of All Selected DOFs</h2>
<p>All selected DOFs that did not determine <img class="formulaInl" alt="$ t_i^{\,sync} $" src="form_7.png"/> have to be synchronized to this time value. In principal, an infinite number of solutions can be found to parameterize a trajectory that transfers such a degree of freedom from <img class="formulaInl" alt="$ _k\vec{M}_i $" src="form_16.png"/> to <img class="formulaInl" alt="$ _k\vec{M}_i^{\,trgt} $" src="form_17.png"/> in <img class="formulaInl" alt="$ t_i^{\,sync} $" src="form_7.png"/>. In order to achieve a deterministic framework, an optimization criterion must be used in order to compute a <em>time-</em> or a <em>phase-synchronized</em> motion trajectory. Therefore, another decision tree is used, which selects a motion profile <img class="formulaInl" alt="$ _k\Psi_i^{\,Step2} $" src="form_18.png"/> for each DOF <img class="formulaInl" alt="$ k $" src="form_19.png"/> from a different set that is denoted by <img class="formulaInl" alt="$ {\cal P}_{Step2} $" src="form_20.png"/>. Based on this profile, a nonlinear system of equations can be solved, and the solution contains all required parameters for the synchronized motion trajectory.</p>
<p><br/>
 <br/>
</p>
<hr/>
<h2><a class="anchor" id="sec_Step3"></a>
Step 3: Calculate Output Values</h2>
<p>This last step is trivial: the resulting trajectory parameters of Step 2 are used to calculate a new state of motion <img class="formulaInl" alt="$ {\bf M}_{i+1} $" src="form_3.png"/>, which is used as set-point for lower-level controllers at <img class="formulaInl" alt="$ T_{i+1}$" src="form_21.png"/>.<br/>
</p>
<div align="center">
<img src="GenericStructogram.png" alt="GenericStructogram.png"/>
<p><strong>Nassi-Shneiderman structogram of the basic OTG algorithm.</strong></p></div>
<p> The figure above summarizes the generic version of the OTG algorithm for time-synchronization, while the figure below summarizes the version, in which phase-synchronization is applied.<br/>
</p>
<div align="center">
<img src="GenericStructogramPS.png" alt="GenericStructogramPS.png"/>
<p><strong>Generic Nassi-Shneiderman structogram for the OTG algorithm for phase-synchronized trajectories.</strong></p></div>
<p> The class <a class="el" href="class_reflexxes_a_p_i.html" title="This class constitutes the API of the Reflexxes Motion Libraries">ReflexxesAPI</a> constitutes the actual user interface and provides the complete set of functionalities while hiding all parts of the library that are not required by the user. Users, who like to take a deeper look to the implementation of the algorithm, may learn about the class TypeIVRMLPosition and the namespace TypeIVRMLMath, both of which contain all mathematical details. </p>
</div></div>
<hr class="footer"/>
<address style="text-align: right;">
	<small>
		User documentation of the <i>Reflexxes Motion Libraries</i> by
		Reflexxes GmbH (<a href="page__imprint.html" ><b>Company Information</b></a>). This document was generated with <a href="http://www.doxygen.org" target="_blanc" title="www.doxygen.org"><b>Doxygen</b></a> on Tue Oct 1 2013 13:30:04. Copyright 2010&ndash;2013.
	</small>
</address>
</body>
<?php
include("./iplog.php");
?>
</html>


